#!/bin/bash
# By Yoann Delouis (ydelouis) <ydelouis@gmail.com>
# Inspired by Romain Vimont (®om) <rom@rom1v.com>
# And Martin Gondermann (magicmonty)
#
# Link this file to ~/gitbashprompt and replace 'PS1' initialization in your
# ~/.bashrc by:
#    . /full/path/to/your/gitbashprompt
#
# See <http://blog.rom1v.com/2012/04/prompt-bash-pour-git/>

__git_bash_prompt() {

 ### Init colors
  local nocol='\001\e[0m\002'
  # branch color
  local col='\001\e[36m\002' # blue
  # detached HEAD color
  local dcol='\001\e[31m\002' # red
  # conflict color
  local ccol='\001\e[31m\002' # red
  # Clean color
  local clcol='\001\e[32m\002' # green
 ###

 ### Init symbols
  # ahead
  local asym="↑"
  # behind
  local bsym="↓"
  # conflict
  local csym="✘"
  # staged
  local ssym="●"
  # unstaged
  local ussym="~"
  # untracked
  local utsym="…"
  # clean
  local clsym="✔"
 ###

 ### Split current path
  SFI="$IFS"
  IFS=/
  local path="$1"
  local folders=($path)
  path=${path/\~/$HOME}
  local count=${#folders[@]}
  IFS="$SFI"
 ### 
 
 ### For all folders of path
  local i=0
  local folder= # current folder for printing
  local efolder= # current folder for using in scripts
  local curpath= # path of folder which is currently written
  local toplevel=$(git rev-parse --show-toplevel 2> /dev/null) # closer git 
  while [ $i -lt $count ]
  do
   ### Set folder and efolder
    folder="${folders[$i]}"
    efolder="$folder"
   ###

   ### Print / before the folder if not the first of if path is only /
    if [ $i -gt 0 -o "$path" = / ]
    then
      printf /
      curpath="$curpath/"
    fi
   ###
 
   ### Deal with ~
    if [ "$folder" = "~" ]
    then
      efolder="$HOME"
    fi
   ###
   
   ### Append efolder to current path 
    curpath="$curpath$efolder"
   ###

   ### Print folder and git infos
    printf "$folder"
    cd "$efolder"
    if [ -e .git ]
    then
      __git_branch 
      if [ "$curpath" = "$toplevel" ]
      then
        printf $col"("
        __git_branch_status
        __git_status
        printf ")"$nocol
      fi
    fi
   ###

   ### Increment i
    i=$(($i+1))
   ###
  done
}

__git_branch() {
  gitinfo="$(git branch 2>/dev/null | sed -n 's/^* //p')"
  if [ "$gitinfo" ]
  then
    if [ "$gitinfo" = "(no branch)" ]
    then
      gitinfo="$(git describe 2>/dev/null ||
                 git rev-list HEAD -1 | cut -c-7)"
      printf $col@$dcol"$gitinfo"$nocol
    else
      printf $col@"$gitinfo"$nocol
    fi
  fi
}

__git_branch_status() {
  branch=$(git branch 2>/dev/null | sed -n 's/^* //p')
  if [ "$branch" != "(no branch)" ]
  then
    remote=$(git config branch."$branch".remote 2>/dev/null) &&
    rmbranch=$(git config branch."$branch".merge | cut -c 12-) &&
    revlist=$(git rev-list --left-right refs/remotes/"$remote"/"$rmbranch"...HEAD) && 
    (
      ahead=$(echo "$revlist" | grep -c "^>")
      behind=$(echo "$revlist" | grep -c "^<")
      if [ $ahead != "0" ]
      then
        printf "$asym$ahead"
      fi
      if [ $behind != "0" ]
      then
        printf "$bsym$behind"
      fi
      if [ $ahead != "0" -o $behind != "0" ]
      then
        printf "|"
      fi
    )
  fi
}

__git_status() {
  status=$(git status --porcelain | cut -c 1-2) 
  conflict=$(echo "$status" | grep -c -e "DD" -e "AA" -e "U")
  if [ $conflict != "0" ]
  then
    printf "$ccol$conflict$csym$col"
  else
    staged=$(echo "$status" | grep -c -e "^M" -e "^A" -e "^D" -e "^R" -e "^C") 
    unstaged=$(echo "$status" | grep -c -e "M$" -e "D$")
    untracked=$(echo "$status" | grep -c "??")
    if [ $staged != "0" -o $unstaged != "0" -o $untracked != "0" ]
    then
      if [ $staged != "0" ]
      then
        printf "$ssym$staged"
      fi
      if [ $unstaged != "0" ]
      then
        printf "$ussym$unstaged"
      fi
      if [ $untracked != "0" ]
      then 
        printf "$utsym$untracked"
      fi
    else
      printf "$clcol""$clsym""$col"
    fi
  fi
}

PS1='\u@\h:$(__git_bash_prompt "\w")\$ '
